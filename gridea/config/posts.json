{
  "posts": [
    {
      "content": "https://leetcode-cn.com/problems/array-partition-i/\n数组\n\n给定长度为 2n 的整数数组 nums ，你的任务是将这些数分成 n 对, 例如 (a1, b1), (a2, b2), ..., (an, bn) ，使得从 1 到 n 的 min(ai, bi) 总和最大。\n\n返回该 最大总和 。\n<!-- more -->\n😅评论说的好,这是比各个语言的排序速度吧\n最大总和 - 排序后返回奇数项之和\n最小总和 - 排序后返回前n项\n```\nclass Solution {\npublic:\n    int arrayPairSum(vector<int>& nums) {\n        std::sort(nums.begin(),num.end());\n        int res = 0;\n        for(int i = 0 ; i <nums.size() ; i = i+2){\n            res += nums[i];\n        }\n        return res;\n    }\n};\n```\n```\nclass Solution:\n    def arrayPairSum(self, nums: List[int]) -> int:\n        nums.sort()\n        return sum(nums[::2])\n```\n",
      "data": {
        "title": "LeetCode 561 数组拆分",
        "date": "2021-02-16 09:59:53",
        "tags": [],
        "published": true,
        "hideInList": false,
        "feature": null,
        "isTop": false
      },
      "isEmpty": false,
      "excerpt": "",
      "abstract": "https://leetcode-cn.com/problems/array-partition-i/\n数组\n\n给定长度为 2n 的整数数组 nums ，你的任务是将这些数分成 n 对, 例如 (a1, b1), (a2, b2), ..., (an, bn) ，使得从 1 到 n 的 min(ai, bi) 总和最大。\n\n返回该 最大总和 。",
      "fileName": "leetcode-561-shu-zu-chai-fen"
    },
    {
      "content": "path optimizer根据boundaries生成了很多条空间上的path\n在进行速度规划之前，需要先验证生成的path的合理性\n<!-- more -->\n\nfile:modules/planning/tasks/deciders/path_assessment_decider/path_assessment_decider.cc\n\n代码的注释还是比较清晰的，主要分成四部分：\n>1. Remove invalid path.\n>2. Analyze and add important info for speed decider to use\n>3. Pick the optimal path.\n>4. Update necessary info for lane-borrow decider's future uses.\n\n### 1.Remove invalid path\n#### Is valid fallback path \n设置了3个条件来验证fallbackpath的合理性\n- 轨迹点不为空\n- 距离参考线不是特别远(20m)\n- 距离左右车道线不是特别远（10m）\n\n```\n  // Basic sanity checks.\n  if (path_data.Empty()) {\n    ADEBUG << \"Fallback Path: path data is empty.\";\n    return false;\n  }\n  // Check if the path is greatly off the reference line.\n  if (IsGreatlyOffReferenceLine(path_data)) {\n    ADEBUG << \"Fallback Path: ADC is greatly off reference line.\";\n    return false;\n  }\n  // Check if the path is greatly off the road.\n  if (IsGreatlyOffRoad(reference_line_info, path_data)) {\n    ADEBUG << \"Fallback Path: ADC is greatly off road.\";\n    return false;\n  }\n  return true;\n```\n#### Is valid regulat path\n设置了5个条件来验证常规path的合理性\n- 轨迹点不为空\n- 距离参考线不是特别远(20m)\n- 距离左右车道线不是特别远（10m）\n- 与静态障碍物没有发生碰撞：path不应当与静态障碍物发生碰撞\n- 不会停在反向道路上：检查终点不在目标车道上\n```\n  // Basic sanity checks.\n  if (path_data.Empty()) {\n    ADEBUG << path_data.path_label() << \": path data is empty.\";\n    return false;\n  }\n  // Check if the path is greatly off the reference line.\n  if (IsGreatlyOffReferenceLine(path_data)) {\n    ADEBUG << path_data.path_label() << \": ADC is greatly off reference line.\";\n    return false;\n  }\n  // Check if the path is greatly off the road.\n  if (IsGreatlyOffRoad(reference_line_info, path_data)) {\n    ADEBUG << path_data.path_label() << \": ADC is greatly off road.\";\n    return false;\n  }\n  // Check if there is any collision.\n  if (IsCollidingWithStaticObstacles(reference_line_info, path_data)) {\n    ADEBUG << path_data.path_label() << \": ADC has collision.\";\n    return false;\n  }\n\n  if (IsStopOnReverseNeighborLane(reference_line_info, path_data)) {\n    ADEBUG << path_data.path_label() << \": stop at reverse neighbor lane\";\n    return false;\n  }\n```\n\n### 2.Analyze and add important info for speed decider to use\n添加一些信息供speed decider使用\n\n对于涉及换道的path，需要标记出换道点的位置（in lane 、 out lane）\n\n对于block的轨迹，需要标记出block的位置\n\n### 3. Pick the optimal path.\n挑选最好的path\n\n\n\n\nto do \nstd bind    std placeholders\n\n\n\n",
      "data": {
        "title": "Path Assessment Decider",
        "date": "2021-02-08 14:31:16",
        "tags": [],
        "published": true,
        "hideInList": false,
        "feature": null,
        "isTop": false
      },
      "isEmpty": false,
      "excerpt": "",
      "abstract": "path optimizer根据boundaries生成了很多条空间上的path\n在进行速度规划之前，需要先验证生成的path的合理性",
      "fileName": "path-assessment-decider"
    },
    {
      "content": "如下图所示，frenet坐标系下，给定边界，使用优化的思想求解轨迹\n[![y1of1I.png](https://s3.ax1x.com/2021/02/04/y1of1I.png)](https://imgchr.com/i/y1of1I)\n<!-- more -->\n\n在frenet坐标系下，规划一条在平滑（舒适）、安全（限定空间）的轨迹。\n定义代价函数包括平滑性、靠近中心线、终点，在上下边界内求解使代价函数最小的目标轨迹\n\n### Optimality Modeling\n>We consider the following factors in modeling the optimality of a path:\n>1) Collision-free The path must not intersect with obstacles in the environment.\n >2) Minimal lateral deviation If there is no collision risk, the vehicle should stay as close to the center of the lane  as possible.\n>3) Minimal lateral movement The lateral movement and its rate of change must be minimized. These two terms implicitly represent how quickly the vehicle moves laterally.\n>4) (Optional)Maximal obstacle distance Maximize the distance between the vehicle and the obstacles to allow clearance for the vehicle to pass through safely. This factor turns out can be represented as the distance between the vehicle and the center of its corresponding path boundary.\n\n从以下角度出发来规划和评价path：\n    1 无碰撞\n    2 最小横向偏差 - 沿中心线行驶\n    3 最小横向位移 - 降低横向位移和位移频率\n    4 （可选）远离障碍物\n从而设计cost:\n$$\nminimize\\ f(l(s)) = w_l\\cdot \\int l(s)^2ds + w_{l'}\\cdot \\int l'(s)^2ds +  w_{l''}\\cdot \\int l''(s)^2ds +  w_{l'''}\\cdot \\int l'''(s)^2ds +\\\\\n w_{obs} \\cdot\\int (l(s) - 0.5*(l_B(s)_{min} + l_B(s)_{max}))^2ds + \\\\\nw_{end_l}\\cdot (l_{n-1} - l_{endref})^2 + w_{end_{dl}}\\cdot ({l}'_{n-1}-{l_{endref}}')^2 + w_{end_{ddl}}\\cdot ({l}''_{n-1} - {l_{endref}}'')^2\\\\\n$$\nsubject to the safety constraint:\n$$\nl(s)\\in l_B(s), \\forall s\\in [0,s_{max}]\n$$\n在cost中：\n    第一行表示平滑，l,l',l'',l'''最小\n    第二行表示中心线，尽量沿中心线行驶\n    第三行表示终点权重\n\n### Formulation\n>To effectively formulate an optimization problem and evaluate constraint satisfaction in practice, our approach discretizes the path function l(s) according to the spatial parameter s to a certain resolution ∆s, and uses these discretized points to control the shape of the path, and approximately evaluate constraint satisfactions. Same ap- proach has been used in our previously published work . The key idea is to discretize the 1-dimensional function to second-order derivative level, and use constant third-order derivative terms to “connect” consecutive discretized points. Third order derivative of a positional variable is commonly named jerk. Thus this formulation is named piecewise-jerk method.\n\nfrenet坐标系下，沿固定距离△s将路径均匀采样\n使用常三阶多项式连接各个点（每段曲线的三阶导数jerk为常量）\n$$\n\\begin{matrix} l_0\\\\l_0'\\\\l_0'' \\end{matrix} \n\\overset{\\Delta s}{\\rightarrow}\n\\begin{matrix} l_1\\\\l_1'\\\\l_1'' \\end{matrix} \n\\overset{\\Delta s}{\\rightarrow}\n\\begin{matrix} l_2\\\\l_2'\\\\l_2'' \\end{matrix} \n...\n\\begin{matrix} l_{n-2}\\\\l_{n-2}'\\\\l_{n-2}'' \\end{matrix} \n\\overset{\\Delta s}{\\rightarrow}\n\\begin{matrix} l_{n-1}\\\\l_{n-1}'\\\\l_{n-1}'' \\end{matrix} \n$$\n三阶导数是常量，那么有:\n$$\nl_{i\\rightarrow i+1}''' = \\frac{l_{i+1}'' - l_i''}{\\Delta s}\n$$\n积分得到：\n$$\n{l_{i+1}}'' = \\int_{0}^{\\Delta s}{l_{i->i+1}}'''ds={l_i}''+{l_{i->i+1}}'''\\cdot\\Delta s\\\\\n{l_{i+1}}'={l_i}'+\\int_{0}^{\\Delta s}{l}''(s)ds={l_i}'+{l_i}''\\cdot\\Delta s+\\frac{1}{2}{l_{i->i+1}}'''\\cdot\\Delta s^2\\\\\nl_{i+1}=l_i+\\int_{0}^{\\Delta s}{l}'(s)ds\\\\=l_i+(l_i)'\\cdot\\Delta s+\\frac{1}{2}{l_i}''\\cdot s^2+\\frac{1}{6}{l_{i->i+1}}'''\\cdot\\Delta s^3\n$$\n\n\n### qp problem \n#### qp的一般形式\n$$\nminimize \\frac{1}{2} \\cdot x^T \\cdot P \\cdot x + q \\cdot x \\\\\ns.t. LB \\leq A\\cdot x \\leq UB\n$$\n#### 将cost转为qp格式\n以4个点P1,P2,P3,P4为例\n我们要求解的矩阵x为：\n$$\n\\begin{vmatrix}\nl_1\\\\\nl_2\\\\\nl_3\\\\\nl_4\\\\\nl_1'\\\\\nl_2'\\\\\nl_3'\\\\\nl_4'\\\\\nl_1''\\\\\nl_2''\\\\\nl_3''\\\\\nl_4''\\\\\n\\end{vmatrix}\n$$\n先看cost中的平滑项：\n$$\nw_l\\cdot \\sum_{i=0}^{n-1} l_i^2 + w_{{l}'}\\cdot \\sum_{i=0}^{n-1} {l_i}'^2 + w_{{l}''}\\cdot \\sum_{i=0}^{n-1} {l_i}''^2 + w_{{l}'''}\\cdot \\sum_{i=0}^{n-2}(\\frac{{l_{i+1}}'' - {l_i}''}{\\Delta s})^2 \\\\\n$$\n转为P矩阵\n$$\\begin{vmatrix}\nw_l&0&0&0&0&0&0&0&0&0&0&0\\\\\n0&w_l&0&0&0&0&0&0&0&0&0&0\\\\\n0&0&w_l&0&0&0&0&0&0&0&0&0\\\\\n0&0&0&w_l&0&0&0&0&0&0&0&0\\\\\n0&0&0&0&w_{{l}'}&0&0&0&0&0&0&0\\\\\n0&0&0&0&0&w_{{l}'}&0&0&0&0&0&0\\\\\n0&0&0&0&0&0&w_{{l}'}&0&0&0&0&0\\\\\n0&0&0&0&0&0&0&w_{{l}'}&0&0&0&0\\\\\n0&0&0&0&0&0&0&0&w_{{l}''}+\\frac{w_{{l}'''}}{\\Delta s^2}&0&0&0\\\\\n0&0&0&0&0&0&0&0&-2\\frac{w_{{l}'''}}{\\Delta s^2}&w_{{l}''}+2\\frac{w_{{l}'''}}{\\Delta s^2}&0&0\\\\\n0&0&0&0&0&0&0&0&0&-2\\frac{w_{{l}'''}}{\\Delta s^2}&w_{{l}''}+2\\frac{w_{{l}'''}}{\\Delta s^2}&0\\\\\n0&0&0&0&0&0&0&0&0&0&-2\\frac{w_{{l}'''}}{\\Delta s^2}&w_{{l}''}+\\frac{w_{{l}'''}}{\\Delta s^2}\\\\\n\\end{vmatrix}$$\n\nref项的cost：\n$$\nw_{obs}\\cdot \\sum_{i=0}^{n-1}(l_i-l_{ref})^2 \\\\\n$$\n转为P矩阵：\n$$\\begin{vmatrix}\nw_{ref_1}&0&0&0&0&0&0&0&0&0&0&0\\\\\n0&w_{ref_2}&0&0&0&0&0&0&0&0&0&0\\\\\n0&0&w_{ref_3}&0&0&0&0&0&0&0&0&0\\\\\n0&0&0&w_{ref_4}&0&0&0&0&0&0&0&0\\\\\n\\end{vmatrix}$$\n和q矩阵：\n$$\\begin{vmatrix}\n-2w_{ref_1}\\cdot l_{ref_1}\\\\\n-2w_{ref_2}\\cdot l_{ref_2}\\\\\n-2w_{ref_3}\\cdot l_{ref_3}\\\\\n-2w_{ref_4}\\cdot l_{ref_4}\\\\\n\\end{vmatrix}$$\n\nend_state的cost：\n$$\nw_{end_l}\\cdot (l_{n-1} - l_{endref})^2 + w_{end_{dl}}\\cdot ({l}'_{n-1}-{l_{endref}}')^2 + w_{end_{ddl}}\\cdot ({l}''_{n-1} - {l_{endref}}'')^2\n$$\n转为P矩阵：\n$$\n\\begin{vmatrix}\n0&0&0&0&0&0&0&0&0&0&0&0\\\\\n0&0&0&0&0&0&0&0&0&0&0&0\\\\\n0&0&0&0&0&0&0&0&0&0&0&0\\\\\n0&0&0&w_{end_l}&0&0&0&0&0&0&0&0\\\\\n0&0&0&0&0&0&0&0&0&0&0&0\\\\\n0&0&0&0&0&0&0&0&0&0&0&0\\\\\n0&0&0&0&0&0&0&0&0&0&0&0\\\\\n0&0&0&0&0&0&0&w_{end_{dl}}&0&0&0&0\\\\\n0&0&0&0&0&0&0&0&0&0&0&0\\\\\n0&0&0&0&0&0&0&0&0&0&0&0\\\\\n0&0&0&0&0&0&0&0&0&0&0&0\\\\\n0&0&0&0&0&0&0&0&0&0&0&w_{end_{ddl}}\n\\end{vmatrix}\n$$\n和q矩阵：\n$$\\begin{vmatrix}\n0\\\\\n0\\\\\n0\\\\\n-2w_{end_l}\\cdot end_l\\\\\n0\\\\\n0\\\\\n0\\\\\n-2w_{end_dl}\\cdot end_dl\\\\\n0\\\\\n0\\\\\n0\\\\\n-2w_{end_ddl}\\cdot end_ddl\\\\\n\\end{vmatrix}$$\n\n上面三个矩阵加在一起，就得到了我们最终需要的P矩阵和q矩阵。\n（省略了code中的scale_factor 项\n\n#### 将bound转为qp格式\nbound主要由三部分组成：\n    - 在path bound decider中获取的上下边界\n    - l' l'' l'''的约束\n    - 起点约束\n    - 数学约束，上述的l,l',l'',l'''的数学关系\n\n拆开来看,\n1.道路边界(l)约束：\n$$\n\\begin{bmatrix}\nlb_{s1} \\\\ \nlb_{s2} \\\\ \nlb_{s3} \\\\\nlb_{s4} \n\\end{bmatrix} \n \\leq \n \\begin{bmatrix} \n1&0&0&0&0&0&0&0&0&0&0&0&\\\\\n0&1&0&0&0&0&0&0&0&0&0&0&\\\\\n0&0&1&0&0&0&0&0&0&0&0&0&\\\\\n0&0&0&1&0&0&0&0&0&0&0&0&\\\\\n \\end{bmatrix} \n x \n \\leq  \n \\begin{bmatrix}\nub_{s1} \\\\ \nub_{s2} \\\\ \nub_{s3} \\\\\nub_{s4} \n \\end{bmatrix}\n$$\n2. tan(heading)(l'，)约束，目前为固定值2.0：\n$$\n \\begin{bmatrix}\n-2.0 \\\\ \n-2.0 \\\\ \n-2.0 \\\\\n-2.0 \n\\end{bmatrix} \n \\leq \n \\begin{bmatrix} \n0&0&0&0&1&0&0&0&0&0&0&0\\\\\n0&0&0&0&0&1&0&0&0&0&0&0\\\\\n0&0&0&0&0&0&1&0&0&0&0&0\\\\\n0&0&0&0&0&0&0&1&0&0&0&0\\\\\n \\end{bmatrix} \n x \n \\leq  \n \\begin{bmatrix}\n2.0 \\\\ \n2.0 \\\\ \n2.0 \\\\\n2.0 \n \\end{bmatrix}\n$$ \n3.kappa(l'')约束，道路kappa±自车允许的最大kappa：\n$$\n\\begin{bmatrix}\n-lat\\_acc\\_bound + kappa_{s1} \\\\ \n-lat\\_acc\\_bound + kappa_{s2} \\\\ \n-lat\\_acc\\_bound + kappa_{s3} \\\\\n-lat\\_acc\\_bound + kappa_{s4} \n\\end{bmatrix} \n \\leq \n \\begin{bmatrix} \n0&0&0&0&0&0&0&0&1&0&0&0\\\\\n0&0&0&0&0&0&0&0&0&1&0&0\\\\\n0&0&0&0&0&0&0&0&0&0&1&0\\\\\n0&0&0&0&0&0&0&0&0&0&0&1\\\\\n \\end{bmatrix} \n x \n \\leq  \n \\begin{bmatrix}\nlat\\_acc\\_bound + kappa_{s1} \\\\ \nlat\\_acc\\_bound + kappa_{s2} \\\\ \nlat\\_acc\\_bound + kappa_{s3} \\\\\nlat\\_acc\\_bound + kappa_{s4} \n \\end{bmatrix}\n$$\n4. jerk约束：\n由上面的jerk表达式：\n$$\nl_{i\\rightarrow i+1}''' = (l_{i+1}'' - l_i'') / \\Delta s\n$$\njerk bound的计算没有看懂，用的是kappa/vehicle_speed?\n```\ndouble PiecewiseJerkPathOptimizer::EstimateJerkBoundary(\n    const double vehicle_speed, const double axis_distance,\n    const double max_yaw_rate) const {\n  return max_yaw_rate / axis_distance / vehicle_speed;\n}\n```\n转为矩阵形式：\n$$\n\\begin{bmatrix}\n-jerk_1 * \\Delta s \\\\ \n-jerk_2 * \\Delta s \\\\ \n-jerk_3 * \\Delta s \n\\end{bmatrix} \n \\leq \n \\begin{bmatrix} \n0&0&0&0&0&0&0&0&-1&1&0&0\\\\\n0&0&0&0&0&0&0&0&0&-1&1&0\\\\\n0&0&0&0&0&0&0&0&0&0&-1&1\\\\\n \\end{bmatrix} \n x \n \\leq  \n \\begin{bmatrix}\njerk_1 * \\Delta s \\\\ \njerk_2 * \\Delta s \\\\ \njerk_3 * \\Delta s \n \\end{bmatrix}\n$$\n5.起点约束\n$$ \n\\begin{bmatrix}\nego_l \\\\ \nego_{dl} \\\\ \nego_{ddl} \\\\\n\\end{bmatrix} \n \\leq \n \\begin{bmatrix} \n1&0&0&0&0&0&0&0&0&0&0&0\\\\\n0&0&0&0&1&0&0&0&0&0&0&0\\\\\n0&0&0&0&0&0&0&0&1&0&0&0\\\\\n \\end{bmatrix} \n x \n \\leq  \n \\begin{bmatrix}\nego_l \\\\ \nego_{dl} \\\\ \nego_{ddl} \\\\\n \\end{bmatrix}\n$$\n6. 数学关系 - l'' -> l'约束\n对该式\n$$\n{l_{i+1}}'={l_i}'+\\int_{0}^{\\Delta s}{l}''(s)ds={l_i}'+{l_i}''\\cdot\\Delta s+\\frac{1}{2}{l_{i\\rightarrow i+1}}'''\\cdot\\Delta s^2\\\\\n$$\n将jerk式代入，有：\n$$\nl_{i+1}' - l_i' - 0.5\\Delta s *l_i'' - 0.5\\Delta s *l_{i+1}'' = 0\n$$\n也就是：\n$$\n\\begin{bmatrix}\n0 \\\\ \n0 \\\\ \n0 \n\\end{bmatrix} \n \\leq \n \\begin{bmatrix} \n0&0&0&0&-1&1&0&0&-0.5\\cdot\\Delta s&-0.5\\cdot\\Delta s&0&0\\\\\n0&0&0&0&0&-1&1&0&0&-0.5\\cdot\\Delta s&-0.5\\cdot\\Delta s&0\\\\\n0&0&0&0&0&0&-1&1&0&0&-0.5\\cdot\\Delta s&-0.5\\cdot\\Delta s\\\\\n \\end{bmatrix} \n x \n \\leq  \n \\begin{bmatrix}\n0 \\\\ \n0 \\\\ \n0 \n \\end{bmatrix}\n$$\n\n7. 数学关系 - l' -> l 约束\n和上面的方法一样，\n由\n$$\nl_{i+1}=l_i+\\int_{0}^{\\Delta s}{l}'(s)ds=l_i+(l_i)'\\cdot\\Delta s+\\frac{1}{2}{l_i}''\\cdot s^2+\\frac{1}{6}{l_{i\\rightarrow i+1}}'''\\cdot\\Delta s^3\n$$\n得到：\n$$\nl_{i+1} - l_i - \\Delta s \\cdot l_i' - \\frac{1}{2} \\Delta s ^2 \\cdot l_i'' - \\frac{1}{6} \\Delta s^3 \\cdot l_{i+1}'' = 0\n$$\n转为矩阵：\n$$\n\\begin{bmatrix}\n0 \\\\ \n0 \\\\ \n0 \n\\end{bmatrix} \n \\leq \n  \\begin{bmatrix} \n-1&1&0&0&-\\Delta s&0&0&0&-\\frac{1}{2}\\Delta s^2&-\\frac{1}{6}\\Delta s^3&0&0\\\\\n0&-1&1&0&0&-\\Delta s&0&0&0&-\\frac{1}{2}\\Delta s^2&-\\frac{1}{6}\\Delta s^3&0\\\\\n0&0&-1&1&0&0&-\\Delta s&0&0&0&-\\frac{1}{2}\\Delta s^2&-\\frac{1}{6}\\Delta s^3\\\\\n \\end{bmatrix} \n x \n \\leq  \n \\begin{bmatrix}\n0 \\\\ \n0 \\\\ \n0 \n \\end{bmatrix}\n$$\n\n以上就是整个formulate problem的过程，通过以上步骤完成了P,q,A,LB,UB五个矩阵，接下来使用osqp求解器进行求解\n\n\n\n### Reference\nOptimal Vehicle Path Planning Using Quadratic Optimization for Baidu Apollo Open Platform (2020 IEEE Intelligent Vehicles Symposium (IV) October 20-23,     2020. Las Vegas, USA)",
      "data": {
        "title": "Piecewise Jerk Path Optimizer",
        "date": "2021-02-07 13:41:06",
        "tags": [],
        "published": true,
        "hideInList": false,
        "feature": null,
        "isTop": false
      },
      "isEmpty": false,
      "excerpt": "",
      "abstract": "如下图所示，frenet坐标系下，给定边界，使用优化的思想求解轨迹\n[![y1of1I.png](https://s3.ax1x.com/2021/02/04/y1of1I.png)](https://imgchr.com/i/y1of1I)",
      "fileName": "piecewise-jerk-path-optimizer"
    },
    {
      "content": "前面几个decider更偏向于make decision，通过外部环境选择自车的动作\n接下来的目标是根据道路、障碍物以及前几步的decision-making建立数学模型来求解轨迹\n\n视频：\n<iframe src=\"//player.bilibili.com/player.html?aid=289090335&bvid=BV1qf4y1r7o5&cid=292510772&page=1\" scrolling=\"no\" border=\"0\" frameborder=\"no\" height=\"480\" width=\"720\" framespacing=\"0\" allowfullscreen=\"true\"> </iframe>\n<!-- more -->\n\n[![y1of1I.png](https://s3.ax1x.com/2021/02/04/y1of1I.png)](https://imgchr.com/i/y1of1I)\n\n如上图所示，在frenet坐标系下，假设自车目前位置为s=0，l = 0\n将车道线和障碍物转为自车两侧的边界线（图中红线），再均分得到中心线（灰线），\n通过设计cost，将轨迹求解问题转为在boundary内求解l,dl,ddl,使cost最小的二次规划问题（通过求解器进行求解，图中蓝线为得到的解）。\n\nPath Bound Decider的目的就是将车道线和障碍物转为上图中的边界\n\n### 初始化\nTask初始化，根据参考线建立frenet坐标系，计算自车在frenet坐标系中的位置(s,l,s',l'),同时计算自车到车道中心线的距离以及左右车道宽度。\n\n接下来生成path bound，每个path bound都会在后续生成一条轨迹。\n### Fall Back pathbound\n首先生成一条默认的fall back pathbound，在正常求解轨迹无解或失败的情况下使用。\n长度为(车速×8秒 , 100m)取大，间距为0.5m。\n接下来遍历前方道路，依据下方规则生成左右两侧的boundary\n如图：\n[![y3FVx0.png](https://s3.ax1x.com/2021/02/04/y3FVx0.png)](https://imgchr.com/i/y3FVx0)\n\n根据车道生成左右的lane_bound，从地图中获得\n根据自车状态生成adc_bound，adc_bound = adc_l_to_lane_center_ + ADC_speed_buffer + adc_half_width + ADC_buffer\n\n上式中的各项：\nadc_l_to_lane_center_ - 自车\nadc_half_width - 车宽\nadc_buffer - 0.5\n左侧当前s对应的bound取MAX(left_lane_bound,left_adc_bound),\n右侧当前s对应的bound取MIN(right_lane_bound,right_adc_bound)（取远的）\nADCSpeedBuffer表示横向的瞬时位移？ 公式如下：\n$$ADCSpeedBuffer = \\frac{l'^2}{2\\cdot kMaxLatAcc}$$ \n其中kMaxLatAcc = 1.5\n\n\n### Regular Path Bound\n接下来生成常规path boundary，根据当前场景(pull_over,lane_change,lane_borrow)选择对应的生成方法。以常规的LaneBorrowPath Bound为例：\n#### Lane Borrow Path Bound\n默认会生成一条不借道的bound，从path_decider_status中取出当前的借道状态，\n有左换道就生成一条左换道的bound，\n有右换道就生成一条右换道的bound，\n都有就都生成。\n```\n  // Generate regular path boundaries.\n  std::vector<LaneBorrowInfo> lane_borrow_info_list;\n  lane_borrow_info_list.push_back(LaneBorrowInfo::NO_BORROW);\n\n  if (reference_line_info->is_path_lane_borrow()) {\n    const auto& path_decider_status =\n        injector_->planning_context()->planning_status().path_decider();\n    for (const auto& lane_borrow_direction :\n         path_decider_status.decided_side_pass_direction()) {\n      if (lane_borrow_direction == PathDeciderStatus::LEFT_BORROW) {\n        lane_borrow_info_list.push_back(LaneBorrowInfo::LEFT_BORROW);\n      } else if (lane_borrow_direction == PathDeciderStatus::RIGHT_BORROW) {\n        lane_borrow_info_list.push_back(LaneBorrowInfo::RIGHT_BORROW);\n      }\n    }\n  }\n  ```\n根据车道和自车状态生成boundary和上方fallback是一样的，adc_buffer调整为了0.1\n```\n  // 2. Decide a rough boundary based on lane info and ADC's position\n  if (!GetBoundaryFromLanesAndADC(reference_line_info, lane_borrow_info, 0.1,\n                                  path_bound, borrow_lane_type)) {\n    const std::string msg =\n        \"Failed to decide a rough boundary based on \"\n        \"road information.\";\n    AERROR << msg;\n    return Status(ErrorCode::PLANNING_ERROR, msg);\n  }\n```\n然后根据静态障碍物生成boundary,记录block位置之前的boundary。\n场景示例如下：\n[![y85a5Q.png](https://s3.ax1x.com/2021/02/05/y85a5Q.png)](https://imgchr.com/i/y85a5Q)\n```\n  PathBound temp_path_bound = *path_bound;\n  if (!GetBoundaryFromStaticObstacles(reference_line_info.path_decision(),\n                                      path_bound, blocking_obstacle_id)) {\n    const std::string msg =\n        \"Failed to decide fine tune the boundaries after \"\n        \"taking into consideration all static obstacles.\";\n    AERROR << msg;\n    return Status(ErrorCode::PLANNING_ERROR, msg);\n  }\n  // Append some extra path bound points to avoid zero-length path data.\n  int counter = 0;\n  while (!blocking_obstacle_id->empty() &&\n         path_bound->size() < temp_path_bound.size() &&\n         counter < kNumExtraTailBoundPoint) {\n    path_bound->push_back(temp_path_bound[path_bound->size()]);\n    counter++;\n  }\n```\n先来筛选障碍物，障碍物筛选规则如下，需要符合以下所有的条件，才加到obs_list中：\n    - 不是虚拟障碍物\n    - 不是可忽略的障碍物（其他decider中添加的ignore decision）\n    - 静态障碍物或速度小于FLAGS_static_obstacle_speed_threshold（0.5m/s）\n    - 在自车的前方\n接下来将每个障碍物分解成两个ObstacleEdge，起点一个终点一个，记录下s，start_l,end_l,最后按s排序\n[![y8szJf.png](https://s3.ax1x.com/2021/02/05/y8szJf.png)](https://imgchr.com/i/y8szJf)\n\n对于上图场景中id为2的obstacle，sort后得到的内部数据结构为：\n[![y85LIe.png](https://s3.ax1x.com/2021/02/05/y85LIe.png)](https://imgchr.com/i/y85LIe)\n```\n  for (const auto* obstacle : indexed_obstacles.Items()) {\n    // Only focus on those within-scope obstacles.\n    if (!IsWithinPathDeciderScopeObstacle(*obstacle)) {\n      continue;\n    }\n    // Only focus on obstacles that are ahead of ADC.\n    if (obstacle->PerceptionSLBoundary().end_s() < adc_frenet_s_) {\n      continue;\n    }\n    // Decompose each obstacle's rectangle into two edges: one at\n    // start_s; the other at end_s.\n    const auto obstacle_sl = obstacle->PerceptionSLBoundary();\n    sorted_obstacles.emplace_back(\n        1, obstacle_sl.start_s() - FLAGS_obstacle_lon_start_buffer,\n        obstacle_sl.start_l() - FLAGS_obstacle_lat_buffer,\n        obstacle_sl.end_l() + FLAGS_obstacle_lat_buffer, obstacle->Id());\n    sorted_obstacles.emplace_back(\n        0, obstacle_sl.end_s() + FLAGS_obstacle_lon_end_buffer,\n        obstacle_sl.start_l() - FLAGS_obstacle_lat_buffer,\n        obstacle_sl.end_l() + FLAGS_obstacle_lat_buffer, obstacle->Id());\n  }\n```\n```\n  std::sort(sorted_obstacles.begin(), sorted_obstacles.end(),\n            [](const ObstacleEdge& lhs, const ObstacleEdge& rhs) {\n              if (std::get<1>(lhs) != std::get<1>(rhs)) {\n                return std::get<1>(lhs) < std::get<1>(rhs);\n              } else {\n                return std::get<0>(lhs) > std::get<0>(rhs);\n              }\n            });\n```\n依次遍历按S排列的ObstacleEdge后，得到bound，就是下图中的红线\n[![y1of1I.png](https://s3.ax1x.com/2021/02/04/y1of1I.png)](https://imgchr.com/i/y1of1I)\n整体思路类似一条直线向前扫，扫到ObstacleEdge进入或退出就更新一下边界，\n\n当左边界和右边界有重叠时，认为参考线被blocked，记录下位置。\n\n\n\n\n### Reference\n#### ReferenceLine::ToFrenetFrame\n需要将起点转为frenet坐标系\ncartesian to frenet reference :\n[Frenet坐标系与Cartesian坐标系互转](https://blog.csdn.net/u013468614/article/details/108748016)\n[Apollo项目坐标系研究](https://blog.csdn.net/davidhopper/article/details/79162385) ",
      "data": {
        "title": "Path Bounds Decider",
        "date": "2021-02-04 15:28:28",
        "tags": [],
        "published": true,
        "hideInList": false,
        "feature": null,
        "isTop": false
      },
      "isEmpty": false,
      "excerpt": "",
      "abstract": "前面几个decider更偏向于make decision，通过外部环境选择自车的动作\n接下来的目标是根据道路、障碍物以及前几步的decision-making建立数学模型来求解轨迹\n\n视频：\n<iframe src=\"//player.bilibili.com/player.html?aid=289090335&bvid=BV1qf4y1r7o5&cid=292510772&page=1\" scrolling=\"no\" border=\"0\" frameborder=\"no\" height=\"480\" width=\"720\" framespacing=\"0\" allowfullscreen=\"true\"> </iframe>",
      "fileName": "path-bounds-decider"
    },
    {
      "content": "首先看一下自车当前的状态path_decider_status\n```\nauto* mutable_path_decider_status = injector_->planning_context()\n                                          ->mutable_planning_status()\n                                          ->mutable_path_decider();\n```\npath_decider_status是定义在proto中的结构体(modules/planning/proto/planning_status.proto),包括前方obs的counter、id，以及允许借道的方向等\n```\nmessage PathDeciderStatus {\n  enum LaneBorrowDirection {\n    LEFT_BORROW = 1;   // borrow left neighbor lane\n    RIGHT_BORROW = 2;  // borrow right neighbor lane\n  }\n  optional int32 front_static_obstacle_cycle_counter = 1 [default = 0];\n  optional int32 able_to_use_self_lane_counter = 2 [default = 0];\n  optional bool is_in_path_lane_borrow_scenario = 3 [default = false];\n  optional string front_static_obstacle_id = 4 [default = \"\"];\n  repeated LaneBorrowDirection decided_side_pass_direction = 5;\n}\n```\n如果当前已经在借道状态了，并且自车车道可用的counter >=6，取消lane_borrow scenario 状态\n```\nif (mutable_path_decider_status->able_to_use_self_lane_counter() >= 6) {\n      // If have been able to use self-lane for some time, then switch to\n      // non-lane-borrowing.\n      mutable_path_decider_status->set_is_in_path_lane_borrow_scenario(false);\n      mutable_path_decider_status->clear_decided_side_pass_direction();\n      AINFO << \"Switch from LANE-BORROW path to SELF-LANE path.\";\n    }\n```\n然后是一串黑名单，用于筛除不需要借道的场景，判断是否确实需要换道\n只有当以下条件都满足时，才认为需要借道：\n- HasSingleReferenceLine:只有一条参考线\n\n\n```\n\n```\n`frame.reference_line_info().size() == 1;`\n- IsWithinSidePassingSpeedADC:自车车速较低 (18km/h)\n`frame.PlanningStartPoint().v() < FLAGS_lane_borrow_max_speed`\n- IsBlockingObstacleFarFromIntersection：参考线被障碍物遮挡，并且障碍物不在特殊区域（路口、人行横道等）附近（20m）\n- IsLongTermBlockingObstacle：长期遮挡参考线（counter >=3）\n`front_static_obstacle_cycle_counter() >=FLAGS_long_term_blocking_obstacle_cycle_threshold`\n- IsBlockingObstacleWithinDestination:障碍物不在终点附近\n- IsSidePassableObstacle：障碍物最终确认，在modules/planning/common/obstacle_blocking_analyzer.cc :bool IsNonmovableObstacle函数中，包括：\n    - 前方最近的障碍物距离自车不是很远（35m）\n    `obstacle.PerceptionSLBoundary().start_s() > adc_sl_boundary.end_s() + kAdcDistanceThreshold`\n    - 前方最近的障碍物在路边，或者是在停车道上\n    ```\n    bool is_parked = is_on_parking_lane || is_at_road_edge;\n    return is_parked && obstacle->IsStatic();\n    ```\n    - 前方最近的障碍物的前方（15m内）没有其他障碍物\n对应代码：\n```\n    // ADC requirements check for lane-borrowing:\n    if (!HasSingleReferenceLine(frame)) {\n      return false;\n    }\n    if (!IsWithinSidePassingSpeedADC(frame)) {\n      return false;\n    }\n\n    // Obstacle condition check for lane-borrowing:\n    if (!IsBlockingObstacleFarFromIntersection(reference_line_info)) {\n      return false;\n    }\n    if (!IsLongTermBlockingObstacle()) {\n      return false;\n    }\n    if (!IsBlockingObstacleWithinDestination(reference_line_info)) {\n      return false;\n    }\n    if (!IsSidePassableObstacle(reference_line_info)) {\n      return false;\n    }\n```\n\n满足了以上条件后，首先检查左右的车道线是否为实线和双黄线\n```\n    if (*left_neighbor_lane_borrowable) {\n      lane_boundary_type = hdmap::LeftBoundaryType(waypoint);\n      if (lane_boundary_type == hdmap::LaneBoundaryType::SOLID_YELLOW ||\n          lane_boundary_type == hdmap::LaneBoundaryType::SOLID_WHITE) {\n        *left_neighbor_lane_borrowable = false;\n      }\n      ADEBUG << \"s[\" << check_s << \"] left_lane_boundary_type[\"\n             << LaneBoundaryType_Type_Name(lane_boundary_type) << \"]\";\n    }\n    if (*right_neighbor_lane_borrowable) {\n      lane_boundary_type = hdmap::RightBoundaryType(waypoint);\n      if (lane_boundary_type == hdmap::LaneBoundaryType::SOLID_YELLOW ||\n          lane_boundary_type == hdmap::LaneBoundaryType::SOLID_WHITE) {\n        *right_neighbor_lane_borrowable = false;\n      }\n      ADEBUG << \"s[\" << check_s << \"] right_neighbor_lane_borrowable[\"\n             << LaneBoundaryType_Type_Name(lane_boundary_type) << \"]\";\n    }\n```\n将可以借道的方向添加到decided_side_pass_direction中，is_in_path_lane_borrow_scenario置为True\n如果两个方向都不能借道，is_in_path_lane_borrow_scenario置为false\n```\nif (path_decider_status.decided_side_pass_direction().empty()) {\n      // first time init decided_side_pass_direction\n      bool left_borrowable;\n      bool right_borrowable;\n      CheckLaneBorrow(reference_line_info, &left_borrowable, &right_borrowable);\n      if (!left_borrowable && !right_borrowable) {\n        mutable_path_decider_status->set_is_in_path_lane_borrow_scenario(false);\n        return false;\n      } else {\n        mutable_path_decider_status->set_is_in_path_lane_borrow_scenario(true);\n        if (left_borrowable) {\n          mutable_path_decider_status->add_decided_side_pass_direction(\n              PathDeciderStatus::LEFT_BORROW);\n        }\n        if (right_borrowable) {\n          mutable_path_decider_status->add_decided_side_pass_direction(\n              PathDeciderStatus::RIGHT_BORROW);\n        }\n      }\n    }\n```",
      "data": {
        "title": "PATH_LANE_BORROW_DECIDER 借道处理",
        "date": "2021-02-04 14:50:26",
        "tags": [
          "Apollo"
        ],
        "published": true,
        "hideInList": false,
        "feature": null,
        "isTop": false
      },
      "isEmpty": false,
      "excerpt": "",
      "abstract": "",
      "fileName": "path_lane_borrow_decider-jie-dao-chu-li"
    },
    {
      "content": "换道时复用上一时刻的轨迹，配置中默认关闭了。\n如果有Path Reuse的话，就不需要跑下面的PATH_LANE_BORROW_DECIDER、PATH_BOUND_DECIDER了\n",
      "data": {
        "title": "PATH_REUSE_DECIDER ",
        "date": "2021-02-04 14:49:41",
        "tags": [
          "Apollo"
        ],
        "published": true,
        "hideInList": false,
        "feature": null,
        "isTop": false
      },
      "isEmpty": false,
      "excerpt": "",
      "abstract": "",
      "fileName": "path_reuse_decider"
    },
    {
      "content": "File Path: modules/planning/tasks/deciders/lane_change_decider/lane_change_decider.cc\n\n首先取出上一刻的换道状态prev_status\n```\nauto* prev_status = injector_->planning_context()\n                          ->mutable_planning_status()\n                          ->mutable_change_lane();\n```\nprev_status是定义在proto中的结构体(modules/planning/proto/planning_status.proto)\n包括：\nStatus - IN_CHANGE_LANE、CHANGE_LANE_FAILED 、CHANGE_LANE_FINISHED\npath_id、timestamp\n\nexist_lane_change_start_position - 换道起点flag\nlane_change_start_postion - 换道起点\n\nlast_succeed_timestamp\n\nis_current_opt_succeed - path和speed是否规划成功\nis_clear_to_change_lane - 周围环境是否clear\n```\nmessage ChangeLaneStatus {\n  enum Status {\n    IN_CHANGE_LANE = 1;        // during change lane state\n    CHANGE_LANE_FAILED = 2;    // change lane failed\n    CHANGE_LANE_FINISHED = 3;  // change lane finished\n  }\n  optional Status status = 1;\n  // the id of the route segment that the vehicle is driving on\n  optional string path_id = 2;\n  // the time stamp when the state started.\n  optional double timestamp = 3;\n  // the starting position only after which lane-change can happen.\n  optional bool exist_lane_change_start_position = 4 [default = false];\n  optional apollo.common.Point3D lane_change_start_position = 5;\n  // the last time stamp when the lane-change planning succeed.\n  optional double last_succeed_timestamp = 6;\n  // if the current path and speed planning on the lane-change\n  // reference-line succeed.\n  optional bool is_current_opt_succeed = 7 [default = false];\n  // denotes if the surrounding area is clear for ego vehicle to\n  // change lane at this moment.\n  optional bool is_clear_to_change_lane = 8 [default = false];\n}\n```\n将初始状态初始化为CHANGE_LANE_FINISHED：\n```\n  if (!prev_status->has_status()) {\n    UpdateStatus(now, ChangeLaneStatus::CHANGE_LANE_FINISHED,\n                 GetCurrentPathId(*reference_line_info));\n    prev_status->set_last_succeed_timestamp(now);\n    return Status::OK();\n  }\n  ```\n在有多条参考线的情况下认为可以换道\n`bool has_change_lane = reference_line_info->size() > 1;`\n然后进行换道状态的判断，逻辑框图大致如下：\n![](https://pickteemo.github.io//post-images/1612340002243.jpg)\n\n更新状态后Lane_Change_Decider就跑完了。\n\n\n相关内容：\n\n1. 这里有个疑问，reference_line_info > 1时就直接进入IN_CHANGE_LANE了，\n也就是说只有在需要换道时，routing才会给出多条参考线吗？\n\n2. 在lane_change_decider的配置中有一项reckless_change_line,默认关闭，打开后直接执行优先换道然后退出task，和正常的相比少了failed_freeze_time和success_freeze_time.\n\n3. PrioritizeChangeLane（）函数，传True表示优先处理换道path，False表示优先处理当前path。\n具体做法为：遍历Reference_line_inf（std::list type），找到第一个符合要求的path（True- ischangelane || False - is not changelane），将它插回Reference_line_info的头部\n代码：\n```\nauto iter = reference_line_info->begin();\n  while (iter != reference_line_info->end()) {\n    ADEBUG << \"iter->IsChangeLanePath(): \" << iter->IsChangeLanePath();\n    /* is_prioritize_change_lane == true: prioritize change_lane_reference_line\n       is_prioritize_change_lane == false: prioritize\n       non_change_lane_reference_line */\n    if ((is_prioritize_change_lane && iter->IsChangeLanePath()) ||\n        (!is_prioritize_change_lane && !iter->IsChangeLanePath())) {\n      ADEBUG << \"is_prioritize_change_lane: \" << is_prioritize_change_lane;\n      ADEBUG << \"iter->IsChangeLanePath(): \" << iter->IsChangeLanePath();\n      break;\n    }\n    ++iter;\n  }\n  reference_line_info->splice(reference_line_info->begin(),\n                              *reference_line_info, iter);\n```\n[链接：std::list<T>::splice on cppreference](https://zh.cppreference.com/w/cpp/container/list/splice )\n",
      "data": {
        "title": "LANE_CHANGE_DECIDER 换道状态处理",
        "date": "2021-02-04 14:46:38",
        "tags": [
          "Apollo"
        ],
        "published": true,
        "hideInList": false,
        "feature": null,
        "isTop": false
      },
      "isEmpty": false,
      "excerpt": "",
      "abstract": "",
      "fileName": "lane_change_decider"
    },
    {
      "content": "https://algorithmsbook.com/\n\n### INTRO\nThis book provides a broad introduction to algorithms for decision making under uncertainty. We cover a wide variety of topics related to decision making, introducing the underlying mathematical problem formulations and the algorithms for solving them.",
      "data": {
        "title": "ALGORITHMS FOR DECISION MAKING - MYKEL J. KOCHENDERFER, TIM A. WHEELER, AND KYLE H. WRAY",
        "date": "2021-02-04 14:13:06",
        "tags": [],
        "published": true,
        "hideInList": false,
        "feature": null,
        "isTop": false
      },
      "isEmpty": false,
      "excerpt": "",
      "abstract": "",
      "fileName": "algorithms-for-decision-making-mykel-j-kochenderfer-tim-a-wheeler-and-kyle-h-wray"
    },
    {
      "content": "目录：modules/planning/math/discretized_points_smoothing/fem_pos_deviation_osqp_interface.cc\n\n平滑类比较独立，所以单独摘出来看\n\n设计了三个代价函数，分别代表了平滑性、曲线总长度和参考点距离\n\n另外注意到，大部分场景都是只考虑平滑性（平滑性权重默认设置为1e7，其他的权重设置为1）\n\n[只有在OpenSpacePlanner中，多考虑了一点到原参考点距离，权重设置的也比较低，只有1e3](https://github.com/ApolloAuto/apollo/commit/3decb9251da7e10b8ddf730c92cb1834a551b099)\n\n因此下方，以6个点P0,P1,P2...P6为例子，只考虑平滑性代价时：\n$cost = \\sum_{i=0}^{n-2}((x_i + x_{i+2}-2\\times x_{i+1})^2 + (y_i + y_{i+2}-2\\times y_{i+1})^2)$\n将上方cost乘开，转为QP公式\n$$\n\\frac{1}{2}\\cdot x^T\\cdot Q\\cdot x+p^T\\cdot x\\\\\ns.t. LB \\leq A\\cdot x \\leq UB\n$$\n没有一次项，p矩阵为0\nQ矩阵如下：\n$$\n\\begin{vmatrix}\n1 & -2 & 1 & 0 & 0 & 0\\\\ \n-2 & 5 & -4 & 1 & 0 & 0\\\\ \n1 & -4 & 6 & -4 & 1 & 0\\\\ \n0 & 1 & -4 & 6 & -4 & 1\\\\ \n0 & 0 & 1 & -4 & 5 & -2\\\\ \n0 & 0 & 0 & 1 & 2 & 1\n\\end{vmatrix}\n$$\n\nLB和UB是根据左右道路宽度来取的\n设置完成后调用osqp求解器进行求解\n\n除了平滑性，还配置了曲线总长度和参考线距离两个代价函数。\n曲线总长度代价，使用积分进行运算：\n$cost = \\sum_{i=0}^{n-1}(x_i - x_{i+1})^2 + (y_i - y_{i+1})^2$\n转为QP公式，一次项为0\n二次项矩阵：\n$$\n\\begin{vmatrix}\n1 & -2 & 0 & 0 & 0 & 0\\\\ \n0 & 2 & -2 & 0 & 0 & 0\\\\ \n0 & 0 & 2 & -2 & 0 & 0\\\\ \n0 & 0 & 0 & 2 & -2 & 0\\\\ \n0 & 0 & 0 & 0 & 2 & -2\\\\ \n0 & 0 & 0 & 0 & 0 & 1\n\\end{vmatrix}\n$$\n\n到原参考点的距离：\n$cost = \\sum_{i=0}^{n-1}(x_i - x_{ref})^2 + (y_i - y_{ref})^2$\nQ矩阵：\n$$\n\\begin{vmatrix}\n1 & 0 & 0 & 0 & 0 & 0\\\\ \n0 & 1 & 0 & 0 & 0 & 0\\\\ \n0 & 0 & 1 & 0 & 0 & 0\\\\ \n0 & 0 & 0 & 1 & 0 & 0\\\\ \n0 & 0 & 0 & 0 & 1 & 0\\\\ \n0 & 0 & 0 & 0 & 0 & 1\n\\end{vmatrix}\n$$\nq矩阵：\n$$\n\\begin{vmatrix}\n-2\\cdot x_{ref1}\\\\\n-2\\cdot x_{ref2}\\\\\n-2\\cdot x_{ref3}\\\\\n-2\\cdot x_{ref4}\\\\\n-2\\cdot x_{ref5}\\\\\n-2\\cdot x_{ref6}\n\\end{vmatrix}\n$$",
      "data": {
        "title": "fem_pos_deviation_smoother",
        "date": "2021-02-04 09:03:04",
        "tags": [
          "Apollo"
        ],
        "published": true,
        "hideInList": false,
        "feature": null,
        "isTop": false
      },
      "isEmpty": false,
      "excerpt": "",
      "abstract": "",
      "fileName": "fem_pos_deviation_smoother"
    },
    {
      "content": "Know the loom. Be the stone\n\n<!-- more -->\n> 欢迎来到我的小站呀，很高兴遇见你！🤝\n\n## 📃List\n- Apollo\n    - Reference Line Provider\n        - [Fem Pos Deviation Smoother](https://pickteemo.github.io/post/fem_pos_deviation_smoother/)\n    - [Lane Follow Stage](https://pickteemo.github.io/post/lanefollowstage/)\n        - [Lane Change Decider](https://pickteemo.github.io/post/lane_change_decider/)\n        - [Path Reuse Decider](https://pickteemo.github.io/post/path_reuse_decider/)\n        - [Lane Borrow Decider](https://pickteemo.github.io/post/path_lane_borrow_decider-jie-dao-chu-li/)\n        - [Path Bound Decider](https://pickteemo.github.io/post/path-bounds-decider/)\n        - [Piecewise Jerk Path Optimizer](https://pickteemo.github.io/post/piecewise-jerk-path-optimizer/)\n- [Tools](https://pickteemo.github.io/post/tools)\n- Paper and Book\n    - [algorithms for decision making](https://pickteemo.github.io/post/algorithms-for-decision-making-mykel-j-kochenderfer-tim-a-wheeler-and-kyle-h-wray/)\n\n\n\n\n## 👨‍💻 博主是谁\n大乱斗职业选手\n## 📬 联系我呀\npppickteemo@gmail.com\nqq : 1059014365",
      "data": {
        "title": "About & List",
        "date": "2021-02-03 17:16:21",
        "tags": [],
        "published": true,
        "hideInList": false,
        "feature": null,
        "isTop": true
      },
      "isEmpty": false,
      "excerpt": "",
      "abstract": "Know the loom. Be the stone",
      "fileName": "about"
    },
    {
      "content": "\n配置文件：modules/planning/conf/scenario/lane_follow_config.pb.txt\n\nTASK\n  task_type: LANE_CHANGE_DECIDER\n  task_type: PATH_REUSE_DECIDER\n  task_type: PATH_LANE_BORROW_DECIDER\n  task_type: PATH_BOUNDS_DECIDER  \n  task_type: PIECEWISE_JERK_PATH_OPTIMIZER\n  task_type: PATH_ASSESSMENT_DECIDER\n  task_type: PATH_DECIDER\n  task_type: RULE_BASED_STOP_DECIDER\n  task_type: ST_BOUNDS_DECIDER\n  task_type: SPEED_BOUNDS_PRIORI_DECIDER\n  task_type: SPEED_HEURISTIC_OPTIMIZER\n  task_type: SPEED_DECIDER\n  task_type: SPEED_BOUNDS_FINAL_DECIDER\n  task_type: PIECEWISE_JERK_NONLINEAR_SPEED_OPTIMIZER\n  task_type: RSS_DECIDER\n\n\n",
      "data": {
        "title": "LaneFollowStage",
        "date": "2021-02-03 14:12:08",
        "tags": [
          "Apollo"
        ],
        "published": true,
        "hideInList": false,
        "feature": null,
        "isTop": false
      },
      "isEmpty": false,
      "excerpt": "",
      "abstract": "",
      "fileName": "lanefollowstage"
    },
    {
      "content": "### v2rayA -  Linux client supporting global transparent proxy\n\n[github](https://github.com/v2rayA/v2rayA)\n\n[Usage wiki](https://github.com/v2rayA/v2rayA/wiki/Usage)\n\n### FiraCode - free monospaced font with programming ligatures\n\n[github](https://github.com/tonsky/FiraCode)\n\n[How to Install](https://github.com/tonsky/FiraCode/wiki)\n\n",
      "data": {
        "title": "Tools",
        "date": "2021-02-03 13:08:53",
        "tags": [],
        "published": true,
        "hideInList": false,
        "feature": null,
        "isTop": false
      },
      "isEmpty": false,
      "excerpt": "",
      "abstract": "",
      "fileName": "tools"
    },
    {
      "content": "👏  欢迎使用 **Gridea** ！  \n✍️  **Gridea** 一个静态博客写作客户端。你可以用它来记录你的生活、心情、知识、笔记、创意... ... \n\n<!-- more -->\n\n[Github](https://github.com/getgridea/gridea)  \n[Gridea 主页](https://gridea.dev/)  \n[示例网站](http://fehey.com/)\n\n## 特性👇\n📝  你可以使用最酷的 **Markdown** 语法，进行快速创作  \n\n🌉  你可以给文章配上精美的封面图和在文章任意位置插入图片  \n\n🏷️  你可以对文章进行标签分组  \n\n📋  你可以自定义菜单，甚至可以创建外部链接菜单  \n\n💻  你可以在 **Windows**，**MacOS** 或 **Linux** 设备上使用此客户端  \n\n🌎  你可以使用 **𝖦𝗂𝗍𝗁𝗎𝖻 𝖯𝖺𝗀𝖾𝗌** 或 **Coding Pages** 向世界展示，未来将支持更多平台  \n\n💬  你可以进行简单的配置，接入 [Gitalk](https://github.com/gitalk/gitalk) 或 [DisqusJS](https://github.com/SukkaW/DisqusJS) 评论系统  \n\n🇬🇧  你可以使用**中文简体**或**英语**  \n\n🌁  你可以任意使用应用内默认主题或任意第三方主题，强大的主题自定义能力  \n\n🖥  你可以自定义源文件夹，利用 OneDrive、百度网盘、iCloud、Dropbox 等进行多设备同步  \n\n🌱 当然 **Gridea** 还很年轻，有很多不足，但请相信，它会不停向前 🏃\n\n未来，它一定会成为你离不开的伙伴\n\n尽情发挥你的才华吧！\n\n😘 Enjoy~\n",
      "data": {
        "title": "Hello Gridea",
        "date": "2018-12-12 00:00:00",
        "tags": [
          "Gridea"
        ],
        "published": true,
        "hideInList": false,
        "feature": "/post-images/hello-gridea.png",
        "isTop": false
      },
      "isEmpty": false,
      "excerpt": "",
      "abstract": "👏  欢迎使用 **Gridea** ！  \n✍️  **Gridea** 一个静态博客写作客户端。你可以用它来记录你的生活、心情、知识、笔记、创意... ... ",
      "fileName": "hello-gridea"
    }
  ],
  "tags": [
    {
      "name": "Apollo",
      "slug": "5ydbfF-8m",
      "used": true
    },
    {
      "name": "Gridea",
      "slug": "oplIVzu8H",
      "used": true
    }
  ],
  "menus": [
    {
      "link": "/",
      "name": "首页",
      "openType": "Internal"
    },
    {
      "link": "/archives",
      "name": "归档",
      "openType": "Internal"
    },
    {
      "link": "/tags",
      "name": "标签",
      "openType": "Internal"
    },
    {
      "link": "/post/about",
      "name": "关于",
      "openType": "Internal"
    }
  ]
}